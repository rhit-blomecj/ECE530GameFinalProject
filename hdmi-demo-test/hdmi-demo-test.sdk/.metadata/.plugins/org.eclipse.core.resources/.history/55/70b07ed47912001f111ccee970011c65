#include "project_main.h"
/* ------------------------------------------------------------ */
/*				Global Variables								*/
/* ------------------------------------------------------------ */

/*
 * Display and Video Driver structs
 */
DisplayCtrl dispCtrl;
XAxiVdma vdma;
INTC intc;
char fRefresh; //flag used to trigger a refresh of the Menu on video detect

/*
 * Framebuffers for video data
 */
u8 frameBuf[DISPLAY_NUM_FRAMES][FRAME_ARRAY_SIZE] __attribute__((aligned(0x20)));
u8 *pFrames[DISPLAY_NUM_FRAMES]; //array of pointers to the frame buffers


//I want our screen to be 1280*720
//rgb_val twoDFrame[GAME_RES_WIDTH][GAME_RES_HEIGHT];
//rgb_val * twoDFrameRep[GAME_RES_HEIGHT];

void writeGameScreen(u8 * frame, u32 stride){
	int i;
	for(i = 0; i < GAME_RES_WIDTH; i++){//1280 is screen width
		int j;
		for (j = 0; j < GAME_RES_HEIGHT; j++){//720 is screen height
			if(i < ROW1_COORD || i > ROW5_END_COORD){
				frame[i*3+j*stride] = 0;
				frame[i*3+j*stride + 1] = 0;
				frame[i*3+j*stride + 2] = 0;
//				twoDRGBArray[i][j].blue = 0;
//				twoDRGBArray[i][j].green = 0;
//				twoDRGBArray[i][j].red = 0;
			}
			else{
				frame[i*3+j*stride] = 255;
				frame[i*3+j*stride + 1] = 0;
				frame[i*3+j*stride + 2] = 0;
//				twoDRGBArray[i][j].blue = 255;
//				twoDRGBArray[i][j].green = 0;
//				twoDRGBArray[i][j].red = 0;
			}
		}
	}
}

int main(void)
{
	HardwareInitialize();

	GameRun();

	return 0;
}

void HardwareInitialize()
{
	int Status;
	XAxiVdma_Config *vdmaConfig;
	int i;

	/*
	 * Initialize an array of pointers to the 3 frame buffers
	 */
	for (i = 0; i < DISPLAY_NUM_FRAMES; i++)
	{
		pFrames[i] = frameBuf[i];
	}

	//setup the pointers to my 2 d frame
	// sets up our 2D array for representing frames (C pointer stuff)
//	for (i = 0; i < GAME_RES_HEIGHT; i++)
//	{
//		twoDFrameRep[i] = twoDFrame[i];
//	}
	/*
	 * Initialize a timer used for a simple delay
	 */
	TimerInitialize(SCU_TIMER_ID);

	/*
	 * Initialize VDMA driver
	 */
	vdmaConfig = XAxiVdma_LookupConfig(VDMA_ID);
	if (!vdmaConfig)
	{
		xil_printf("No video DMA found for ID %d\r\n", VDMA_ID);
		return;
	}
	Status = XAxiVdma_CfgInitialize(&vdma, vdmaConfig, vdmaConfig->BaseAddress);
	if (Status != XST_SUCCESS)
	{
		xil_printf("VDMA Configuration Initialization failed %d\r\n", Status);
		return;
	}

	/*
	 * Initialize the Display controller and start it
	 */
	Status = DisplayInitialize(&dispCtrl, &vdma, HDMI_OUT_VTC_ID, DYNCLK_BASEADDR, pFrames, GAME_STRIDE);
	if (Status != XST_SUCCESS)
	{
		xil_printf("Display Ctrl initialization failed during demo initialization%d\r\n", Status);
		return;
	}
	Status = DisplayStart(&dispCtrl);
	if (Status != XST_SUCCESS)
	{
		xil_printf("Couldn't start display during demo initialization%d\r\n", Status);
		return;
	}



	/*
	 * Initialize the Interrupt controller and start it.
	 */
	Status = fnInitInterruptController(&intc);
	if(Status != XST_SUCCESS) {
		xil_printf("Error initializing interrupts");
		return;
	}

	return;
}


void GameRun()
{
	char userInput = 0;

//	writeGameScreen(twoDFrameRep);
//	writePlayer(ROW1_COORD, PLAYER_Y_COORD, twoDFrameRep);
	writeGameScreen(pFrames[dispCtrl.curFrame], GAME_STRIDE);
	Xil_DCacheFlushRange((unsigned int) pFrames[dispCtrl.curFrame], FRAME_ARRAY_SIZE);

	/* Flush UART FIFO */
	while (XUartPs_IsReceiveData(UART_BASEADDR))
	{
		XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET);
	}

	while (userInput != 'q')
	{
		fRefresh = 0;

//		drawFrame(twoDFrameRep, pFrames[dispCtrl.curFrame], dispCtrl.vMode.width, dispCtrl.vMode.height, GAME_STRIDE);
//		Xil_DCacheFlushRange((unsigned int) pFrames[dispCtrl.curFrame], FRAME_ARRAY_SIZE);
		/* Wait for data on UART */
		while (!XUartPs_IsReceiveData(UART_BASEADDR) && !fRefresh)
		{}

		/* Store the first character in the UART receive FIFO and echo it */
		if (XUartPs_IsReceiveData(UART_BASEADDR))
		{
			userInput = XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET);
			xil_printf("%c", userInput);
		}
		else  //Refresh triggered by video detect interrupt
		{
			userInput = 'r';
		}



		switch (userInput)
		{
		case '1':
			DemoChangeRes();
			writeGameScreen(pFrames[dispCtrl.curFrame], GAME_STRIDE);
			Xil_DCacheFlushRange((unsigned int) pFrames[dispCtrl.curFrame], FRAME_ARRAY_SIZE);
//			writeGameScreen(twoDFrameRep);
//			writePlayer(ROW1_COORD, PLAYER_Y_COORD, twoDFrameRep);
			break;
		case '2':
//			writeWhiteTwo(80, 0, twoDFrameRep);
			break;
		case '3':
//			writeWhiteThree(120, 0, twoDFrameRep);
			break;
		case '4':
//			writeWhiteFour(160, 0, twoDFrameRep);
			break;
		case '5':
//			writeWhiteFive(200, 0, twoDFrameRep);
			break;
		case '6':
//			writeWhiteSix(240, 0, twoDFrameRep);
			break;
		case '7':
//			writeWhiteSeven(280, 0, twoDFrameRep);
			break;
		case '8':
//			writeWhiteEight(320, 0, twoDFrameRep);
			break;
		case '9':
//			writeWhiteNine(360, 0, twoDFrameRep);
			break;
		case '0':
//			writeWhiteZero(0,0,twoDFrameRep);
			break;
		case 'q':
			break;
		case 'r':
			break;
		default :
			xil_printf("\n\rInvalid Selection");
			TimerDelay(500000);
		}
	}

	return;
}

//writeWhiteOne(40, 0, twoDFrameRep);





void DemoChangeRes()
{
	int fResSet = 0;
	int status;
	char userInput = 0;

	/* Flush UART FIFO */
	while (XUartPs_IsReceiveData(UART_BASEADDR))
	{
		XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET);
	}

	while (!fResSet)
	{
		DemoCRMenu();

		/* Wait for data on UART */
		while (!XUartPs_IsReceiveData(UART_BASEADDR))
		{}

		/* Store the first character in the UART recieve FIFO and echo it */
		userInput = XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET);
		xil_printf("%c", userInput);
		status = XST_SUCCESS;
		switch (userInput)
		{
		case '1':
			status = DisplayStop(&dispCtrl);
			DisplaySetMode(&dispCtrl, &VMODE_640x480);
			DisplayStart(&dispCtrl);
			fResSet = 1;
			break;
		case '2':
			status = DisplayStop(&dispCtrl);
			DisplaySetMode(&dispCtrl, &VMODE_800x600);
			DisplayStart(&dispCtrl);
			fResSet = 1;
			break;
		case '3':
			status = DisplayStop(&dispCtrl);
			DisplaySetMode(&dispCtrl, &VMODE_1280x720);
			DisplayStart(&dispCtrl);
			fResSet = 1;
			break;
		case '4':
			status = DisplayStop(&dispCtrl);
			DisplaySetMode(&dispCtrl, &VMODE_1280x1024);
			DisplayStart(&dispCtrl);
			fResSet = 1;
			break;
		case '5':
			status = DisplayStop(&dispCtrl);
			DisplaySetMode(&dispCtrl, &VMODE_1600x900);
			DisplayStart(&dispCtrl);
			fResSet = 1;
			break;
		case '6':
			status = DisplayStop(&dispCtrl);
			DisplaySetMode(&dispCtrl, &VMODE_1920x1080);
			DisplayStart(&dispCtrl);
			fResSet = 1;
			break;
		case 'q':
			fResSet = 1;
			break;
		default :
			xil_printf("\n\rInvalid Selection");
			TimerDelay(500000);
		}
		if (status == XST_DMA_ERROR)
		{
			xil_printf("\n\rWARNING: AXI VDMA Error detected and cleared\n\r");
		}
	}
}

void DemoCRMenu()
{
	xil_printf("\x1B[H"); //Set cursor to top left of terminal
	xil_printf("\x1B[2J"); //Clear terminal
	xil_printf("**************************************************\n\r");
	xil_printf("*                ZYBO Video Demo                 *\n\r");
	xil_printf("**************************************************\n\r");
	xil_printf("*Current Resolution: %28s*\n\r", dispCtrl.vMode.label);
	printf("*Pixel Clock Freq. (MHz): %23.3f*\n\r", dispCtrl.pxlFreq);
	xil_printf("**************************************************\n\r");
	xil_printf("\n\r");
	xil_printf("1 - %s\n\r", VMODE_640x480.label);
	xil_printf("2 - %s\n\r", VMODE_800x600.label);
	xil_printf("3 - %s\n\r", VMODE_1280x720.label);
	xil_printf("4 - %s\n\r", VMODE_1280x1024.label);
	xil_printf("5 - %s\n\r", VMODE_1600x900.label);
	xil_printf("6 - %s\n\r", VMODE_1920x1080.label);
	xil_printf("q - Quit (don't change resolution)\n\r");
	xil_printf("\n\r");
	xil_printf("Select a new resolution:");
}


